# Конструирование с нуля или стандартный подход?

## [Назад](../../README.md)

## Проблематика
При обычной разработке игры в Unity все рано или поздно натыкаются на проблемы, общие для всех проектов и связанные напрямую с особенностями движка. Очевидно, что для исправления каждой из них уже существуют готовые решения, но возможно ли изменить подход разработки так, чтобы такие проблемы в принципе не появлялись? Чтобы определить, что можно сделать, для начала нужно точно сформулировать список этих общих проблем:

1. **Инициализация**<br>
   Эта проблема возникает когда один компонент в качестве зависимости требует другой компонент, что является частой ситуацией при декомпозиции. В самом простом случае, когда оба объекта находятся на сцене изначально, мы можем прокинуть эту зависимость через инспектор, однако пробрасываемый объект также может требовать инициализации из-за чего нам становится важен порядок, так как может возникнуть ситуация, когда произойдёт взаимодействие с неинициализированным объектом, что приведёт к ошибкам или некорректному поведению. Удобно контролировать этот процесс стандартными средствами Unity невозможно, так как порядок вызовов Awake и Start для разных объектов определяется внутри Unity и напрямую в него вмешаться нельзя. Ещё хуже становится ситуация, когда нам нужно создавать объекты во время выполнения игры, например, что должны подписываться и отписываться на событие, так как зависимость в таком случае нужна уже в OnEnable, а передать через инспектор возможности нет.
   
   **ExecutionOrder** - самый простой вариант решения проблемы, однако он плохо масштабируется из-за необходимости вручную выставлять приоритеты вне скриптов, что создаёт неявные связи между типами, при этом не решает проблему динамического создания объектов.

   **DI Container** - очень удобный способ разрешения зависимостей в случае, если зависимость это Singleton, однако при необходимости в более гибкой логике начинаются неудобства, например, если нужно прокинуть несколько разных компонентов одного типа в разные компоненты, также одного типа.

   **Composition Root** - самый гибкий вариант, однако он получается самым громоздким, так как большое количество разных объектов инициализируются в единой точке входа, что не делает этот вариант хорошо масштабируемым, не говоря о том, что он не решает проблему внедрения зависимостей в динамически создаваемые объекты.

2. **Сцены**<br>
   В Unity сцены имеют несколько неприятных недоработок:
   
   + **Производительность**<br>
   При каждой смене сцены происходит удаление всех объектов на одной сцене и создание на другой, что в некоторых случаях может быть достаточно тяжёлой операцией. Если уровни в игре проходятся за небольшое время мы получаем крайне неэффективный расход ресурсов, чтобы перейти на другой уровень сначала удалятся все объекты на текущем уровне, после чего создадутся все объекты следующего уровня (если открывать через меню получится на одно создание и удаление всех объектов сцены больше), при этом сами объекты могут очень часто повторяться.

   + **Перенос данных**<br>
   В Unity нет удобного встроенного способа переноса данных между сценами. Остаётся вручную городить хранилище через статику или DontDestroyOnLoad, что крайне небезопасно, так как менять его может кто и где угодно. Как достаточно хорошая альтернатива этому всему существует Typed Scenes, хоть он также имеет ряд проблем.

   + **Объединение веток Git**<br>
   В Unity также нет встроенного способа обработки конфликтов при объединении веток, что создаёт определённые проблемы, учитывая, что все сцены в Unity это просто YAML файлы.

3. **Безопасность**<br>
   В Unity любой компонент может получить доступ к любому другому компоненту или объекту и изменить его, тем самым ни о какой защите состояний объектов не идёт и речи, максимум, что можно сделать это инкапсулировать свой собственный компонент. Подобный подход хоть и даёт невероятную гибкость, но может легко привести к ошибкам времени выполнения.
   
## Решение
Вместо попыток решить каждую проблему по отдельности, предлагаю изменить сам подход к разработке проекта. Для начала введем общие правила:

1. Используем только одну рабочую сцену в Unity (Main), при этом могут быть и другие сцены, но в билд игры они не пойдут, а будут использоваться исключительно для тестирования и настройки на этапе разработки.
2. Изначально на сцене не будет никаких объектов самой игры, все они будут созданы во время выполнения из префабов.
3. Вводим абстракцию над игровыми объектами и компонентами в виде сущностей (Entities). Сущность - это набор объектов и компонентов объединённых под одним корневым объектом, представляющим саму сущность и интерфейс её взаимодействия. Сущность неделима, при этом может включать другие сущности, внутри себя. Каждая сущность должна быть представлена отдельным префабом. Сущности могут взаимодействовать только со своей внутренней реализацией и другими сущностями, через их интерфейс взаимодействия.
4. Все скрипты пишутся без привязки к MonoBehaviour. Взаимодействие с игровыми объектами и стандартными компонентами Unity происходит через сокеты (Sockets), взаимодействие между сущностями происходит в стандартном C# стиле.
5. Игровая логика начинает выполняться с метода Main в классе Game, что должен написать сам пользователь.

Теперь чуть более подробное описание, зачем нужен каждый пункт.

Запретив использование нескольких сцен мы решаем проблему переноса данных и производительности при переходе между сценами, как итог получим очень тяжёлую сцену, что будет долго грузиться, чтобы этого избежать мы будем запускать игру с практически пустой сцены, после чего создавать нужные нам объекты постепенно, пустая сцена также помогает решить проблему объединения веток, так как теперь сама сцена не изменяется.

Чтобы избежать костыльных реализаций конструкторов для MonoBehaviour скриптов мы в принципе откажемся от представления скриптов, как компонентов, благодаря чему получим стандартный конструктор C#. Мы уже сейчас можем организовать единую точку входа в которой будут создаваться и инициализироваться все объекты, как в стандартной C# программе, однако теперь их нужно связать с игровыми объектами и компонентами от Unity, при этом решив последнюю проблему - безопасность.

Для этого предоставим доступ обычным скриптам к компонентной системе Unity через сокеты (специальные компоненты для такого взаимодействия). Чтобы обеспечить безопасность объектов и компонентов на сцене мы сделаем абстракцию в виде сущности, как набора изолированных объектов. Сущность представляется обычным C# классом, но вставляется в специальный сокет и берёт на себя ответственность за управление всеми входящими в неё объектами или другими сущностями, при этом реализация может быть разбита на отдельные скрипты, что вставлены в сокеты на объектах внутри сущности. Безопасность в данном случае обеспечивается благодаря логике сокетов, которые не позволят взаимодействовать сущности или скриптам внутри неё с объектами или компонентами другой сущности.